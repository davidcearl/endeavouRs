---
title: "Shiny App Basics"
author: "David Earl"
date: '2017-10-02'
slug: shiny-app-basics
tags: []
categories: Shiny
---

Shiny is a package for making interactive R apps from RStudio.  
Shiny apps consist of three main components:

+ a ui function  
+ a server function  
+ a call to shiny::runApp(ui = ui, server = server)  

The ui function returns genereated html for the apps user interface.
Shiny has several built in ui functions with can be composed together to create the ui.
These include functions for defining the layout of the app (e.g. `fluidPage()`, `fluidRow()`) as well as functions that specify reactive values that the user can change (e.g. `sliderInput()`, `selectInput()`) and functions for the corresponding output (e.g. `plotOutput()`).  The `*Input()` functions take an inputID as the first argument.  You can then access the input value in the server function by using `input$<inputId>`.

The server function runs R code and reacts to user inputs generating output to display in the ui. The server function must take two arguments `input` and `output`.  Passing `input` allows you to access reactive values specified in the ui using standard R list-like syntax. Similarly, the output of reactive functions is saved to `output$<name>`, which is a list-like object. Output objects are typically generated by using the `render*()` functions

RStudio provides lots of [examples](https://shiny.rstudio.com/articles/basics.html) for defining ui and server functions 

When thinking about reactivity I find it helpful to remember that reactivity is propagated forward in Shiny. Reactive values notify and reactive functions respond. Using an input value in an output object creates a reactive connection. If the input value changes it notifies all output objects it is connected to. A connected output will then get the new value, rerun and return updated output.

***
![](/img/portfolio/asset_2.png)  

***

Reactive values can only be called inside a reactive function!  Reactive fuctions take a code block enclosed in {}.  The entire code block is rerun whenever any called reactive values are changed.  

The common types of reactive functions include the `render*()` family to make objects to display, the `reactive()` function to create intermediate reactive expressions, the `isolate()` function to create a non-reactive object using a reactive value, `observeEvent()` and `observe()` to run code on the server in response to triggers, and the `eventReactive()` function to delay reactions until some other event has occured. 

Reactive expressions keep track of whether or not they have the current reactive values and store the object they return in memory.  They will only rerun if they become invalidated and are called by downstream reactive functions. If they are still valid when called they pass along the cached value.

The figure below diagrams the general flow of a basic app. [^1]

***
![](/img/portfolio/asset_1.png) 

[^1]: adapted from Garrett Grolemund's Shiny video [tutorial](https://player.vimeo.com/video/131218530)